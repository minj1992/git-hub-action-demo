##password-management-rds-password-rotationsan-test
name: san-secrets-lifecycle

on:
  workflow_dispatch:
    inputs:
      runner_label:
        description: "Runner Label"
        required: true
        type: choice
        options:
          - sir-common-runner-ec2
          - sir-san-uat-runner-ec2
        default: "sir-common-runner-ec2"

      AWS_ACCESS_KEY_ID:
        description: "AWS Access Key ID"
        required: true
        default: ""
      AWS_SECRET_ACCESS_KEY:
        description: "AWS Secret Access Key"
        required: true
        default: ""
      AWS_SESSION_TOKEN:
        description: "AWS Session Token"
        required: true
        default: ""

      client_name:
        description: "Client"
        required: true
        type: choice
        options: [san, sample]
        default: "sample"

      environment:
        description: "Environment"
        required: true
        type: choice
        options: [test, q1, q2, q3, s1, d1]
        default: "test"

      secrets_to_rotate:
        description: "Rotate patterns (comma-separated, supports wildcards like /db*)"
        required: false
        default: "/"

      ignore_secret_names:
        description: "Names to ignore (comma-separated, supports wildcards like /db*, relative to /client/env)"
        required: false
        default: ""

jobs:
  backup:
    name: Backup ROTATED + IGNORED + ALL secrets
    runs-on: ${{ github.event.inputs.runner_label }}
    environment: uat

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ github.event.inputs.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ github.event.inputs.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ github.event.inputs.AWS_SESSION_TOKEN }}
          aws-region: eu-west-1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install boto3

      - name: Build backup payloads (ROTATED & IGNORED & ALL)
        id: build
        env:
          CLIENT: ${{ github.event.inputs.client_name }}
          ENV: ${{ github.event.inputs.environment }}
          PATTERNS: ${{ github.event.inputs.secrets_to_rotate }}
          IGNORE: ${{ github.event.inputs.ignore_secret_names }}
        run: |
          python - <<'PY'
          import os, json, boto3, re

          client = os.environ["CLIENT"]
          env = os.environ["ENV"]
          base = f"/{client}/{env}"

          # Inputs
          patterns_raw = [s.strip() for s in os.environ.get("PATTERNS","").split(",") if s.strip()]
          ignore_raw   = [s.strip() for s in os.environ.get("IGNORE","").split(",") if s.strip()]

          def norm(p: str) -> str:
              if not p: return ""
              if p == "/": return base + "/*"
              if p.startswith(base): return p
              if p.startswith("/") and p.count("/") >= 2: return p
              return f"{base}{p}"

          # Normalize and wildcard-adjust
          patterns = [norm(p) for p in patterns_raw] if patterns_raw else [base + "/*"]
          patterns = [(p if p.endswith("/*") or "*" in p else p.rstrip("/") + "/*") for p in patterns]

          ignore_patterns = [norm(p) for p in ignore_raw]
          ignore_patterns = [(p if p.endswith("/*") or "*" in p else p.rstrip("/") + "/*") for p in ignore_patterns]

          sm = boto3.client("secretsmanager")

          # Get all secret names
          names = []
          token = None
          while True:
              resp = sm.list_secrets(NextToken=token) if token else sm.list_secrets()
              for it in resp.get("SecretList", []):
                  name = it.get("Name")
                  if name:
                      names.append(name)
              token = resp.get("NextToken")
              if not token:
                  break

          under_base = [n for n in names if (n == base or n.startswith(base + "/"))]

          # Regex conversion
          def glob_to_regex(g): return "^" + re.escape(g).replace("\\*", ".*") + "$"

          pattern_regs = [re.compile(glob_to_regex(p)) for p in patterns]
          ignore_regs = [re.compile(glob_to_regex(p)) for p in ignore_patterns]

          # Classify
          rotated_set = {n for n in under_base if any(r.match(n) for r in pattern_regs)}
          ignored_set = {n for n in under_base if any(r.match(n) for r in ignore_regs)}

          # Combined backup (union)
          all_set = rotated_set.union(ignored_set)

          # Write payloads
          payload_rotated = {"secrets": [{"name": n} for n in sorted(rotated_set)]}
          payload_ignored = {"secrets": [{"name": n} for n in sorted(ignored_set)]}
          payload_all = {"secrets": [{"name": n} for n in sorted(all_set)]}

          with open("payload_rotated.json","w") as f:
              json.dump(payload_rotated, f, indent=2)
          with open("payload_ignored.json","w") as f:
              json.dump(payload_ignored, f, indent=2)
          with open("payload_all.json","w") as f:
              json.dump(payload_all, f, indent=2)

          # GitHub output
          with open(os.environ["GITHUB_OUTPUT"], "a") as gh:
              gh.write(f"rotated_count={len(rotated_set)}\n")
              gh.write(f"ignored_count={len(ignored_set)}\n")
              gh.write(f"total_count={len(all_set)}\n")

          print(f"‚úÖ Found: {len(rotated_set)} rotated, {len(ignored_set)} ignored, {len(all_set)} total")
          PY

      - name: Backup ROTATED to JSON + ZIP
        if: ${{ steps.build.outputs.rotated_count != '0' }}
        run: |
          python - <<'PY'
          import json, boto3, datetime, zipfile
          sm = boto3.client("secretsmanager")
          with open("payload_rotated.json") as f:
            payload = json.load(f)
          secrets = payload.get("secrets", [])
          ts = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
          json_name = f"secrets-backup-ROTATED-{ts}.json"
          zip_name  = f"secrets-backup-ROTATED-{ts}.zip"
          backup = {"class": "rotated", "timestamp_utc": ts, "items": []}
          for s in secrets:
            name = s["name"]
            try:
              val = sm.get_secret_value(SecretId=name)
              backup["items"].append({"name": name, "secret_string": val.get("SecretString")})
            except Exception as e:
              backup["items"].append({"name": name, "error": str(e)})
          with open(json_name, "w") as f:
            json.dump(backup, f, indent=2)
          with zipfile.ZipFile(zip_name, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.write(json_name, arcname=json_name)
          print(f"‚úÖ Created {zip_name}")
          PY

      - name: Upload ROTATED artifact
        if: ${{ steps.build.outputs.rotated_count != '0' }}
        uses: actions/upload-artifact@v4
        with:
          name: secrets-backup-rotated
          path: secrets-backup-ROTATED-*.zip
          if-no-files-found: error
          compression-level: 0

      - name: Backup IGNORED to JSON + ZIP
        if: ${{ steps.build.outputs.ignored_count != '0' }}
        run: |
          python - <<'PY'
          import json, boto3, datetime, zipfile
          sm = boto3.client("secretsmanager")
          with open("payload_ignored.json") as f:
            payload = json.load(f)
          secrets = payload.get("secrets", [])
          ts = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
          json_name = f"secrets-backup-IGNORED-{ts}.json"
          zip_name  = f"secrets-backup-IGNORED-{ts}.zip"
          backup = {"class": "ignored", "timestamp_utc": ts, "items": []}
          for s in secrets:
            name = s["name"]
            try:
              val = sm.get_secret_value(SecretId=name)
              backup["items"].append({"name": name, "secret_string": val.get("SecretString")})
            except Exception as e:
              backup["items"].append({"name": name, "error": str(e)})
          with open(json_name, "w") as f:
            json.dump(backup, f, indent=2)
          with zipfile.ZipFile(zip_name, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.write(json_name, arcname=json_name)
          print(f"‚úÖ Created {zip_name}")
          PY

      - name: Upload IGNORED artifact
        if: ${{ steps.build.outputs.ignored_count != '0' }}
        uses: actions/upload-artifact@v4
        with:
          name: secrets-backup-ignored
          path: secrets-backup-IGNORED-*.zip
          if-no-files-found: error
          compression-level: 0

      - name: Backup ALL (ROTATED + IGNORED) to JSON + ZIP
        if: ${{ steps.build.outputs.total_count != '0' }}
        run: |
          python - <<'PY'
          import json, boto3, datetime, zipfile
          sm = boto3.client("secretsmanager")
          with open("payload_all.json") as f:
              payload = json.load(f)
          secrets = payload.get("secrets", [])
          ts = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
          json_name = f"secrets-backup-ALL-{ts}.json"
          zip_name  = f"secrets-backup-ALL-{ts}.zip"
          backup = {"class": "all", "timestamp_utc": ts, "items": []}
          for s in secrets:
              name = s["name"]
              try:
                  val = sm.get_secret_value(SecretId=name)
                  backup["items"].append({"name": name, "secret_string": val.get("SecretString")})
              except Exception as e:
                  backup["items"].append({"name": name, "error": str(e)})
          with open(json_name, "w") as f:
              json.dump(backup, f, indent=2)
          with zipfile.ZipFile(zip_name, "w", compression=zipfile.ZIP_DEFLATED) as z:
              z.write(json_name, arcname=json_name)
          print(f"‚úÖ Created combined backup: {zip_name}")
          PY

      - name: Upload ALL artifact
        if: ${{ steps.build.outputs.total_count != '0' }}
        uses: actions/upload-artifact@v4
        with:
          name: secrets-backup-all
          path: secrets-backup-ALL-*.zip
          if-no-files-found: error
          compression-level: 0

      - name: Nothing to back up
        if: ${{ steps.build.outputs.total_count == '0' }}
        run: echo "No rotated or ignored secrets under the selected client/env."

  rotate:
    name: Rotate secrets (after backup)
    needs: backup
    runs-on: ${{ github.event.inputs.runner_label }}
    environment: uat

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ github.event.inputs.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ github.event.inputs.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ github.event.inputs.AWS_SESSION_TOKEN }}
          aws-region: eu-west-1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install boto3

      - name: Build rotation payload (patterns respected)
        id: build
        env:
          CLIENT: ${{ github.event.inputs.client_name }}
          ENV: ${{ github.event.inputs.environment }}
          PATTERNS: ${{ github.event.inputs.secrets_to_rotate }}
          IGNORE: ${{ github.event.inputs.ignore_secret_names }}
        run: |
          python - <<'PY'
          import os, json, re, subprocess
          client, env = os.environ["CLIENT"], os.environ["ENV"]
          base = f"/{client}/{env}"
          patterns = [s.strip() for s in os.environ.get("PATTERNS","").split(",") if s.strip()]
          ignore_raw = [s.strip() for s in os.environ.get("IGNORE","").split(",") if s.strip()]

          def norm(p: str) -> str:
              if not p: return ""
              if p == "/": return base + "/*"
              if p.startswith(base): return p
              if p.startswith("/") and p.count("/") >= 2: return p
              return f"{base}{p}"

          patterns = [norm(p) for p in patterns] if patterns else [base + "/*"]

          result = subprocess.run(
              ["aws","secretsmanager","list-secrets","--query","SecretList[].Name","--output","text"],
              capture_output=True, text=True
          )
          names = [n for n in result.stdout.split() if n]

          def glob_to_regex(g): return "^" + re.escape(g).replace("\\*", ".*") + "$"

          base_names = [n for n in names if (n == base or n.startswith(base + "/"))]
          ignore = set(norm(s) for s in ignore_raw)

          selected = set()
          for pat in patterns:
              rgx = re.compile(glob_to_regex(pat))
              for n in base_names:
                  if n in ignore:
                      continue
                  if rgx.match(n):
                      selected.add(n)

          payload = {"secrets": [{"name": n, "exclude": ["id","username"]} for n in sorted(selected)]}
          with open("rotate_payload.json","w") as f:
              json.dump(payload, f)

          count = len(payload["secrets"])
          with open(os.environ["GITHUB_OUTPUT"], "a") as gh:
              gh.write(f"secrets_count={count}\n")
          print(f"Secrets selected for ROTATION: {count}")
          PY

      - name: Locate lambda_function.py
        id: locate
        run: |
          set -euo pipefail
          FOUND="$(find . -type f -name 'lambda_function.py' | head -n1 || true)"
          if [[ -z "$FOUND" ]]; then
            echo "lambda_function.py not found in repo" >&2
            exit 1
          fi
          echo "path=$FOUND" >> "$GITHUB_OUTPUT"
          echo "Using lambda_function: $FOUND"

      - name: Prepare payload for lambda_function.py
        if: ${{ steps.build.outputs.secrets_count != '0' }}
        run: |
          cp rotate_payload.json payload.json

      - name: Rotate via lambda_function.py
        if: ${{ steps.build.outputs.secrets_count != '0' }}
        env:
          LAMBDA_FILE: ${{ steps.locate.outputs.path }}
        run: |
          python - <<'PY'
          import json, importlib.util, pathlib, sys, os
          p = pathlib.Path(os.environ["LAMBDA_FILE"]).resolve()
          spec = importlib.util.spec_from_file_location("runner_lambda", str(p))
          m = importlib.util.module_from_spec(spec)
          spec.loader.exec_module(m)
          with open("payload.json") as f:
            event = json.load(f)
          res = m.lambda_handler(event, None)
          print(json.dumps(res, indent=2))
          if any(("error" in r) for r in res.get("results", [])):
            sys.exit(1)
          PY

  rds_password_rotation:
    name: RDS user password rotation (after Secrets Manager rotation)
    needs: rotate
    runs-on: ${{ github.event.inputs.runner_label }}
    environment: uat

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo dnf install -y jq postgresql16 || true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ github.event.inputs.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ github.event.inputs.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ github.event.inputs.AWS_SESSION_TOKEN }}
          aws-region: eu-west-1

      - name: Retrieve master DB secret
        id: get_master_secret
        run: |
          SECRET_PATH="/san/qa/psql/master"
          echo "Fetching master secret from: $SECRET_PATH"
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id "$SECRET_PATH" --query SecretString --output text)
          DB_USER=$(echo $SECRET_JSON | jq -r '.id // .username')
          DB_PASSWORD=$(echo $SECRET_JSON | jq -r '.secret // .password')
          DB_HOST=$(echo $SECRET_JSON | jq -r '.host')
          if [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ] || [ -z "$DB_HOST" ]; then
            echo "‚ùå Master secret missing required fields"
            exit 1
          fi
          echo "::add-mask::$DB_PASSWORD"
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
          echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
          echo "‚úÖ Retrieved master credentials for host: $DB_HOST"

      - name: Retrieve DB users to rotate
        id: get_db_users
        run: |
          DB_USERS_SECRET_PATH="/san/qa/db_users"
          echo "Fetching DB users from: $DB_USERS_SECRET_PATH"
          USERS_JSON=$(aws secretsmanager get-secret-value --secret-id "$DB_USERS_SECRET_PATH" --query SecretString --output text)
          echo "$USERS_JSON" > db_users.json
          COUNT=$(jq length db_users.json)
          echo "users_count=$COUNT" >> $GITHUB_OUTPUT
          echo "‚úÖ Found $COUNT users to rotate"

      - name: Rotate user passwords in RDS
        if: ${{ steps.get_db_users.outputs.users_count != '0' }}
        env:
          PGHOST: ${{ steps.get_master_secret.outputs.db_host }}
          PGUSER: ${{ steps.get_master_secret.outputs.db_user }}
          PGPASSWORD: ${{ steps.get_master_secret.outputs.db_password }}
        run: |
          set -euo pipefail
          echo "Starting password rotation..."
          jq -c '.[]' db_users.json | while read user; do
            USERNAME=$(echo "$user" | jq -r '.username')
            PASSWORD=$(echo "$user" | jq -r '.password')
            if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
              echo "‚ö†Ô∏è Skipping invalid user entry"
              continue
            fi
            echo "üîÑ Rotating password for $USERNAME..."
            psql -v ON_ERROR_STOP=1 -tAc "ALTER USER \"$USERNAME\" WITH PASSWORD '$PASSWORD';"
            echo "‚úÖ Password updated for $USERNAME"
          done
          echo "üéâ All passwords rotated successfully."
